package synalp.parsing;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import synalp.commons.derivations.DerivationTree;
import synalp.commons.grammar.Node;
import synalp.commons.input.Lemma;
import synalp.commons.input.TestSuiteEntry;
import synalp.commons.output.MorphRealization;
import synalp.commons.output.SyntacticRealization;
import synalp.commons.semantics.DefaultLiteral;
import synalp.commons.semantics.Semantics;
import synalp.commons.unification.Feature;
import synalp.commons.unification.FeatureValue;
import synalp.commons.unification.FeatureVariable;
import synalp.commons.unification.InstantiationContext;
import synalp.generation.jeni.JeniGenerator;
import synalp.generation.jeni.JeniRealization;
import synalp.parsing.Inputs.Sentence;
import synalp.parsing.Inputs.Word;
import synalp.parsing.dlSemantics.DLNode;
import synalp.parsing.dlSemantics.DLTree;
import synalp.parsing.utils.CustomTextReplacement;



/**
 * The Semantics simply generated by Jeni combinations of trees is not good enough for parsing purposes.
 * Its so because our variables never get a chance of being instantiated as in the case of generation.
 * Therefore, some post Tree combination work has to be done to obtain correct parse semantics and this class does that.
 * In addition, it also creates OWL based representation of the parse semantics so obtained. 
 * @author bikashg
 *
 */

public class ParseResult {
	private DerivationTree derivationTree;
	private JeniRealization realisation; // the sentence that forms after the combination of the trees selected for each word during parse.
	

	private Semantics parseSemantics;  // This is NOT the true result -- it is not instantiated (top-bottom unified)
	private String parseString = ""; // Stores the (top-bottom unified) string representation of parse semantics. The true result. This is the flat semantics.
	private InstantiationContext variablesInstance;
	
	private DLTree dlTree; // This will contain the actual Description Logic axiom
	private ArrayList<String> reverseGenResults;
	
	
	
	/**
	 * There are 3 ways in which we may obtain a partial parse result.
	 * 1. After the lexical selection phase, if for some words, there were no trees selected at all, (for parse tree combinations purpose only) 
	 * we considered as if the word was not in the input. This was specially important for chart based parsing because the no lexical item 
	 * selecting word would make a coloumn in the initial agenda with empty things and when the element of this coloumn would combine with 
	 * others, empty productions would be generated which would further propagate up the chart producing empty results eventaully in the top 
	 * row. However, we intend to have partial results (e.g. "Pipe shall be identified by brown tag" even when the original sentence is 
	 * "Pipe shall be identified by a brown tag" and the lexical entry for "a" is missing) and this strategy helps us achieve that. 
	 * 
	 * 2. When the top row of the chart contained no results and we looked down (from the top row) until the row having some result was present and then we selected the productions at that row as our output.
	 * 
	 * 3. ToDo : (In the past, there were partial results even when I didn't take into account 1 and 2. Need to reproduce the results and find this third cause).   
	 */
	private boolean isCompleteParse; // to indicate if the parse obtained was complete (i.e. the derived tree obtained at the completion of parsing process contains all the words of the input sentence) 
	private ArrayList<String> missingWords; // to keep track of the words of the input sentence that are missing in the derived tree obtained at the completion of parsing process. 
	
	
 	public ParseResult(DerivationTree derivationTree, JeniRealization real, Semantics treeSemantics, InstantiationContext variablesInstance, ArrayList<Word> allWords, ArrayList<Integer> inputSentenceWordOrder) {
		this.derivationTree = derivationTree;
		this.realisation = real;
		this.parseSemantics = treeSemantics;
		this.variablesInstance = variablesInstance;
		
		this.dlTree = new DLTree();
		this.reverseGenResults = new ArrayList<String>();
		
		this.isCompleteParse = false; // by default, set to false.
		this.missingWords = new ArrayList<String>(); // by default, saying that the result has no missing words.
		
		
		computeParseSemantics(allWords);
	}

	public DerivationTree getDerivationTree() {
		return derivationTree;
	}

	private String getInstantiatedVariableValue(String key) {
		for (Map.Entry<FeatureVariable, FeatureValue> entry:variablesInstance.entrySet()) {
			FeatureVariable fvar = entry.getKey();
			FeatureValue fvalue = entry.getValue();
			if (fvar.getName().equalsIgnoreCase(key)) {
				return fvalue.toString();
			}
		}
		return null;
	}
	
	private void computeParseSemantics(ArrayList<Word> allWords) {
		//System.out.println("Initial Semantics = "+parseSemantics);
		// First find the mapping of cases where the top f.s. is a variable and the bottom f.s. is a constant or vice-versa.
		// When the top and bottom f.s. values for any node in the derived tree is not the same, its because they of variable vs. constant
		// since the instantiation and the check for variable unification at the end of the tree combination has already been done.
		Map<String,String> equalVars = new HashMap<String,String>();
		for (Node n:derivationTree.getDerivedTree().getNodes()) {
			for (Feature top_f:n.getFsTop().getAllFeaturesRecursively()) {
				String featureName = top_f.getName();
				if (n.getFsBot().hasFeature(featureName)) {
					String top_var = top_f.getValue().toString();
					String bot_var = n.getFsBot().getValueOf(featureName).toString();
					if (!top_var.equalsIgnoreCase(bot_var)) { // If they are the same, doesn't make sense to store them as equalvars. 
						equalVars.put(top_var, bot_var);
					}
				}
			}
		}
		//System.out.println("\n\n\nEqual Vars = "+equalVars);
		
		// Next get the instantiated variables mappings for the equalvars
		for (Map.Entry<String, String> pair:equalVars.entrySet()) {
			String key = pair.getKey();
			String value = pair.getValue();
			
			String newValue = value;
			String keyReplacer = getInstantiatedVariableValue(key); 
			if (keyReplacer!=null) {
				newValue = keyReplacer;
			}
			String valueReplacer = getInstantiatedVariableValue(value);
			if (valueReplacer!=null) {
				newValue = valueReplacer;
			}
			
			equalVars.put(key, newValue); // Update the value at the same time
		}
		
		
		

		// Then use those mappings to get the parseString
		StringBuilder semanticsString = new StringBuilder();
		for (DefaultLiteral literal:parseSemantics.asList()) {
			String label = literal.getLabel().toString();
			if (equalVars.containsKey(label)) {
				label = equalVars.get(label);
			}
			String predicate = variablesInstance.getValue(literal.getPredicate()).toString();
			semanticsString.append(" "+label+":"+predicate+"(");
			
			
			StringBuilder argsString = new StringBuilder();
			for (FeatureValue arg : literal.getArguments()) {
				String argument = arg.toString(); // default assignment
				// Check for equalVars and if the variable doesn't belong to the set of equalVars, check for its possible instantiated value.
				if (equalVars.containsKey(arg.toString())) {
					argument = equalVars.get(arg.toString());
				}
				else {
					String newValue = getInstantiatedVariableValue(arg.toString());
					if (newValue!=null)
						argument = newValue;
				}
				argsString.append(argument+"#"); // -- # is used as a marker to distinguish arguments while creating DL Tree.
			}
			String args_string = argsString.toString();
			args_string = args_string.substring(0, args_string.length()-1);
			semanticsString.append(args_string+")");
		}
		String text = semanticsString.toString().trim();
		parseString = text;
		//System.out.println("Final Semantics = "+parseString);
	}
	
	
	
	
	public void createDLTree() {
		ArrayList<DLNode> allNodes = new ArrayList<DLNode>();
		for (String literalString:parseString.split(" ")) {
			int colonIndex = literalString.indexOf(":");
			String labelString = literalString.substring(0, colonIndex);
			
			int startBracketIndex = literalString.indexOf("(", colonIndex);
			String predicateString = literalString.substring(colonIndex+1, startBracketIndex);
			
			DLNode node = addDLNode(allNodes, labelString, predicateString);	
			
			String[] argsString = literalString.substring(startBracketIndex+1, literalString.length()-1).split("#");
			for (String argString:argsString) {
				DLNode argumentNode = addDLNode(allNodes, argString);
				node.addChild(argumentNode);
				argumentNode.setParent(node);				
			}
		}
		dlTree.setNodes(allNodes);
	}
	
	/**
	 * If existing node matches to this identifier, update that node with the label info; if not, create a new node and add to the list.
	 * @param allNodes
	 * @param identifier
	 * @param label
	 * @return the node updated/created 
	 */
	private DLNode addDLNode(ArrayList<DLNode> allNodes, String identifier, String label) {
		for (DLNode node:allNodes) {
			if (node.getIdentifier().equalsIgnoreCase(identifier)) {
				node.setLabel(label);
				return node;
			}
		}
		DLNode newNode = new DLNode(identifier,label); 
		allNodes.add(newNode);
		return newNode;
	}
	
	/**
	 * If existing node matches to this identifier, find that node; if not, create a new node and add to the list.
	 * @param allNodes
	 * @param identifier
	 * @param label
	 * @return the node found/created 
	 */
	private DLNode addDLNode(ArrayList<DLNode> allNodes, String identifier) {
		for (DLNode node:allNodes) {
			if (node.getIdentifier().equalsIgnoreCase(identifier)) {
				return node;
			}
		}
		DLNode newNode = new DLNode(identifier); 
		allNodes.add(newNode);
		return newNode;
	}
	
	
	public String getparseString() {
		// We used the # has as a marker for DL Tree computation but we need to replace it by space since that is the semantics that Jeni accepts.
		// Also need to replaceAll "@" with nothing because Jenigenerator doesn't like this. The idea is to feed the output of this parse to Jenigenerator in a reversible engine.
		return parseString.replaceAll("#", " ").replaceAll("@", "");
	}
	
	public DLTree getDLTree() {
		return dlTree;
	}
	
	
	public void computeResultTypeComplete(Sentence inputSentence) {
		if (hasNoMissingWords(inputSentence)) {
			isCompleteParse = true;
		}
		else {
			isCompleteParse = false;
		}
	}
	
	private boolean hasNoMissingWords(Sentence inputSentence) {
		if (inputSentence.getPlainSentence_AllWords().equalsIgnoreCase(getSentenceofParseOutput())) {
			return true;
		}
		else {
			String[] inputs = inputSentence.getPlainSentence_AllWords().split(" ");
			ArrayList<String> parsed = new ArrayList<String>(Arrays.asList(getSentenceofParseOutput().split(" ")));
			for (String x:inputs) {
				if (!parsed.contains(x)) {
					missingWords.add(x);
				}
			}
			return false;
		}
	}
	
	public boolean isResultTypeComplete() {
		return isCompleteParse;
	}
	
	
	public ArrayList<String> getMissingWordsinParseResult() { 
		return missingWords;
	}
	
	
	/**
	 * Given some other config (grammar,lexicon and morph) sets the generationResults to possible sentences that can be generated using the parseString
	 */
	public void  setGeneratedSentences(JeniGenerator generator, int index) {
		Semantics x = Semantics.readSemantics(getparseString());
		reverseGenResults = generateSentencesforSingleSemanticInput(generator, index, x);
	}
	
	/**
	 * Needed for web interface
	 * @param generator
	 * @param index
	 * @param x
	 * @return
	 */
	public static ArrayList<String> generateSentencesforSingleSemanticInput(JeniGenerator generator, int index, Semantics x) {
		ArrayList<String>  ret = new ArrayList<String>();
		TestSuiteEntry entry = new TestSuiteEntry(Integer.toString(index), x, new ArrayList<String>());
		List<? extends SyntacticRealization> generationResults = generator.generate(entry.getSemantics());
		
		for(SyntacticRealization result : generationResults) {
			for(MorphRealization sentence : result.getMorphRealizations()) {
				String obtainedSentence = sentence.asString();
				String formattedSentence = CustomTextReplacement.getDefaultReplacementString(obtainedSentence);
				ret.add(formattedSentence);
			}
		}
		return ret;
	}
	
	public ArrayList<String> getGeneratedSentences() {
		return reverseGenResults;
	}
	
	
	/**
	 * Returns the string that occurs in the derived tree resulting from parse output.
	 * @return
	 */
 	public String getSentenceofParseOutput() {
 		StringBuilder text = new StringBuilder();
 		for (Lemma x: realisation.getLemmas()) {
 			text.append(x.getValue()+" ");
 		}
 		String obtainedSentence = text.toString().trim(); 
 		String formattedSentence = CustomTextReplacement.getDefaultReplacementString(obtainedSentence);
		return formattedSentence;
	}
 	

 	public InstantiationContext getVariablesInstance() {
 		return variablesInstance;
 	}
 	
 	
 	/**
 	 * For testing purposes only; not to be used in production.
 	 * The output semantics to be used in production is returned by the method getparseString()
 	 * @return The parse Sematics obtained after derivation but before top-bottom feature unification.
 	 */
 	public String getSemanticsBeforeTopBottomUnification() {
 		return parseSemantics.toString();
 	}
 	
}
